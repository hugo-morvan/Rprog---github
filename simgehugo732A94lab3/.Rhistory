"https://raw.githubusercontent.com/STIMALiU/AdvRCourse/master/Labs/Tests/lab2.yml"
set_assignment(lab_path)
#1.1 Conditional statments =====================
#1.1.1 ---------------
sheldon_game <- function(player1, player2){
input_options <- c("spock", "scissors", "paper", "rock", "lizard")
win_table = matrix(
c("Draw!",         "Player 2 wins!", "Player 1 wins!",  "Player 2 wins!", "Player 1 wins!",
"Player 1 wins!", "Draw!",         "Player 2 wins!",  "Player 1 wins!", "Player 2 wins!",
"Player 2 wins!", "Player 1 wins!", "Draw!",          "Player 2 wins!", "Player 1 wins!",
"Player 1 wins!", "Player 2 wins!", "Player 1 wins!",  "Draw!",         "Player 2 wins!",
"Player 2 wins!", "Player 1 wins!", "Player 2 wins!",  "Player 1 wins!", "Draw!"),
nrow = 5, ncol = 5, byrow = TRUE
)
rownames(win_table) <- input_options
colnames(win_table) <- input_options
if(player1 %in% input_options && player2 %in% input_options){
win_message <- win_table[player2, player1]
return(win_message)
}else{
stop()
}
}
#1.2 for loops =================================
#1.2.1 ---------------xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
my_moving_median <- function(x, n, ...){
#x is a numeric vector, n a numeric scalar
if(is.numeric(x) && is.numeric(n)){
answer <- c()
for (i in c(1:(length(x)-n))){
med <- median(x = x[i:(i+n)], ...)
answer[i] <- med
}
return(answer)
}else{
stop()
}
}
#1.2.2 ---------------
for_mult_table <- function(from, to){
#pre: from and to are positive integers
#assumed : from <= to ?
stopifnot(is.numeric(from) && is.numeric(to))
table_range <- to - from + 1
range_vec <- c(from:to)
my_table <- matrix(NA, nrow = table_range, ncol = table_range)
rownames(my_table) <- c(from:to)
colnames(my_table) <- c(from:to)
for (i in 1:table_range){
for (j in 1:table_range){
my_table[i,j] <- range_vec[i] * range_vec[j]
}
}
return (my_table)
}
#1.2.3 ---------------
cor_matrix <- function(){
#Optional
}
#1.3 while loops ===============================
#1.3.1 ---------------
find_cumsum <- function(x, find_sum){
stopifnot(is.numeric(x) && is.numeric(find_sum))
cumsum <- 0
index <- 1
while(cumsum < find_sum && index <= length(x) ){
cumsum <- cumsum + x[index]
index <- index + 1
}
return(cumsum)
}
#1.3.2 ---------------
while_mult_table <- function(from, to){
stopifnot(is.numeric(from) && is.numeric(to))
table_range <- to - from + 1
range_vec <- c(from:to)
my_table <- matrix(NA, nrow = table_range, ncol = table_range)
rownames(my_table) <- c(from:to)
colnames(my_table) <- c(from:to)
i <- 0
while(any(is.na(my_table))){
my_table[i,] <- range_vec * range_vec[i]
i <- i + 1
}
return(my_table)
}
#1.3.3 ---------------
trial_division_factorization <- function(){
#Optional
}
#1.4 repeat and loop controls ==================
#1.4.1 ---------------
repeat_find_cumsum <- function(x, find_sum){
stopifnot(is.numeric(x) && is.numeric(find_sum))
cumsum <- 0
index <- 1
repeat{
cumsum <- cumsum + x[index]
index <- index + 1
if (cumsum >= find_sum || index > length(x)){break}
}
return(cumsum)
}
#1.4.2 ---------------xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
repeat_my_moving_median <- function(x, n, ...){
stopifnot(is.numeric(x) && is.numeric(n))
answer <- c()
i <- 1
repeat{
med <- median(x = x[i:(i+n)], ...)
answer[i] <- med
i = i + 1
if( i >= length(x)-n ) {
break
}
}
return(answer)
}
#1.5 Environment ===============================
#1.5.1 ---------------
in_environment <- function(env){
#returns the content of an env as a text vector
my_text <- c(ls(env))
return(my_text)
}
#1.5.2 ---------------
where <- function(){
#Optional
}
#1.6 Functionals ===============================
#1.6.1 ---------------
cov  <- function(X){
stopifnot(is.data.frame(X))
my_vec <- unlist(lapply(X, function(x) sd(x) / mean(x)))
return(my_vec)
}
#1.7 Closures ==================================
#1.7.1 ---------------
moment  <- function(i){
stopifnot(is.numeric(i))
#return a function for the i-th central moment for a given var
#mu_i = E[(X-E[X])^i]
#      = sum((Xi - mean)^i/n
ith_moment <- function(vec){
stopifnot(is.numeric(vec))
vec_mean <- mean(vec)
central_moment <- sum((vec - vec_mean)^i)/length(vec)
return(central_moment)
}
return(ith_moment)
}
#1.7.2 ---------------
mcmc_counter_factory  <- function(){
#Optional
}
mark_my_assignment()
mark_my_assignment("repeat_my_moving_median")
mark_my_assignment("repeat_my_moving_median")
repeat_my_moving_median(x=1:10,2)
#1.4.2 ---------------xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
repeat_my_moving_median <- function(x, n, ...){
stopifnot(is.numeric(x) && is.numeric(n))
answer <- c()
i <- 1
repeat{
med <- median(x = x[i:(i+n)], ...)
answer[i] <- med
i = i + 1
if( i >= length(x)-n+1 ) {
break
}
}
print(answer)
return(answer)
}
repeat_my_moving_median(x=1:10,2)
#1.4.2 ---------------xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
repeat_my_moving_median <- function(x, n, ...){
stopifnot(is.numeric(x) && is.numeric(n))
answer <- c()
i <- 1
repeat{
med <- median(x = x[i:(i+n)], ...)
answer[i] <- med
i = i + 1
if( i >= length(x)-n+1 ) {
break
}
}
return(answer)
}
mark_my_assignment("repeat_my_moving_median")
mark_my_assignment()
mark_my_assignment("trial_division_factorization")
tasks()
tasks
trial_division_factorization(x = 47 * 91 * 97)
#1.3.3 ---------------
trial_division_factorization <- function(x){
#Optional
stopifnot(is.numeric(x))
a <- c()
f <- 2
while (x > 1){
if (n %% f == 0){
append(a,f)
n = n%/%f
}
else{
f = f + 1
}
}
return(a)
}
trial_division_factorization(x = 47 * 91 * 97)
#1.3.3 ---------------
trial_division_factorization <- function(x){
#Optional
stopifnot(is.numeric(x))
a <- c()
f <- 2
while (x > 1){
if (x %% f == 0){
append(a,f)
x = x%/%f
}
else{
f = f + 1
}
}
return(a)
}
trial_division_factorization(x = 47 * 91 * 97)
#1.3.3 ---------------
trial_division_factorization <- function(x){
#Optional
stopifnot(is.numeric(x))
a <- c()
f <- 2
i=1
while (x > 1){
if (x %% f == 0){
a[i] <- f
i = i+1
x = x%/%f
}
else{
f = f + 1
}
}
return(a)
}
trial_division_factorization(x = 47 * 91 * 97)
trial_division_factorization(x = 2^3 * 13 * 17 * 31)
#' Dijkstra's Algorithm
#'
#' @param graph a data frame with columns v1 (from), v2 (to), w (weight)
#' @param init.node the starting node
#' @return the shortest path from init.node to all other nodes
#' @export
#' @examples
#' wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
#'                        v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
#'                       w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
#' dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init.node) {
#pseudo code (source = https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
dist <- c()
prev <- c()
my_queue <- c()
#initialize dist and prev
for (i in 1:nrow(graph)){
dist[i] <- Inf
prev[i] <- NA
my_queue[i] <- i
}
#Set the distance to zero for the initial node
dist[init.node] <- 0
#Set the current node to the initial node
current <- init.node
while(length(my_queue) > 0){
#find the node in the queue with the smallest dist
min.dist <- Inf
for (i in 1:length(my_queue)){
if (dist[my_queue[i]] < min.dist){
min.dist <- dist[my_queue[i]]
current <- my_queue[i]
}
}
#remove current from Q
my_queue <- my_queue[my_queue != current]
#for each neighbor of current
for (i in 1:nrow(graph)){
if (graph[i, 1] == current){
neighbor <- graph[i, 2]
alt <- dist[current] + graph[i, 3]
if (alt < dist[neighbor]){
dist[neighbor] <- alt
prev[neighbor] <- current
}
}
}
}
return(list(dist = dist, prev = prev))
}
wiki_graph <-
data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
#' Dijkstra's Algorithm
#'
#' @param graph a data frame with columns v1 (from), v2 (to), w (weight)
#' @param init.node the starting node
#' @return the shortest path from init.node to all other nodes
#' @export
#' @examples
#' wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
#'                        v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
#'                       w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
#' dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init.node) {
#pseudo code (source = https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
#Checking input
if (nrow(graph) == 0){
stop("The graph is empty")
}
if (init.node > nrow(graph)){
stop("The initial node is not in the graph")
}
dist <- c()
prev <- c()
my_queue <- c()
#initialize dist and prev
for (i in 1:nrow(graph)){
dist[i] <- Inf
prev[i] <- NA
my_queue[i] <- i
}
#Set the distance to zero for the initial node
dist[init.node] <- 0
#Set the current node to the initial node
current <- init.node
while(length(my_queue) > 0){
#find the node in the queue with the smallest dist
min.dist <- Inf
for (i in 1:length(my_queue)){
if (dist[my_queue[i]] < min.dist){
min.dist <- dist[my_queue[i]]
current <- my_queue[i]
}
}
#remove current from Q
my_queue <- my_queue[my_queue != current]
#for each neighbor of current
for (i in 1:nrow(graph)){
if (graph[i, 1] == current){
neighbor <- graph[i, 2]
alt <- dist[current] + graph[i, 3]
if (alt < dist[neighbor]){
dist[neighbor] <- alt
prev[neighbor] <- current
}
}
}
}
#dist is a vector of the shortest distance from the initial node to each node
#ie dist[i] is the shortest distance from the initial node to node i
return(list(dist = dist))
}
wiki_graph <-
data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
dijkstra(wiki_graph, 1)
#' Dijkstra's Algorithm
#'
#' @param graph a data frame with columns v1 (from), v2 (to), w (weight)
#' @param init.node the starting node
#' @return the shortest path from init.node to all other nodes
#' @export
#' @examples
#' wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
#'                        v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
#'                       w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
#' dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init.node) {
#pseudo code (source = https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
#Checking input
if (nrow(graph) == 0) {
stop("The graph is empty")
}
if (init.node > nrow(graph)){
stop("The initial node is not in the graph")
}
dist <- c()
prev <- c()
my_queue <- c()
#initialize dist and prev
for (i in 1:nrow(graph)){
dist[i] <- Inf
prev[i] <- NA
my_queue[i] <- i
}
#Set the distance to zero for the initial node
dist[init.node] <- 0
#Set the current node to the initial node
current <- init.node
while(length(my_queue) > 0) {
#find the node in the queue with the smallest dist
min_dist <- Inf
for (i in 1:length(my_queue)){
if (dist[my_queue[i]] < min_dist) {
min_dist <- dist[my_queue[i]]
current <- my_queue[i]
}
}
#remove current from Q
my_queue <- my_queue[my_queue != current]
#for each neighbor of current
for (i in 1:nrow(graph)) {
if (graph[i, 1] == current) {
neighbor <- graph[i, 2]
alt <- dist[current] + graph[i, 3]
if (alt < dist[neighbor]) {
dist[neighbor] <- alt
prev[neighbor] <- current
}
}
}
}
#dist is a vector of the shortest distance from the init node to each node
#ie dist[i] is the shortest distance from the initial node to node i
return(list(dist = dist))
}
wiki_graph <-
data.frame(v1 = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6),
v2 = c(2, 3, 6, 1, 3, 4, 1, 2, 4, 6, 2, 3, 5, 4, 6, 1, 3, 5),
w = c(7, 9, 14, 7, 10, 15, 9, 10, 11, 2, 15, 11, 6, 6, 9, 14, 2, 9))
print(dijkstra(wiki_graph, 1))
#' Dijkstra's Algorithm
#'
#' @param graph a data frame with columns v1 (from), v2 (to), w (weight)
#' @param init.node the starting node
#' @return the shortest path from init.node to all other nodes
#' @export
#' @examples
#' wiki_graph <- data.frame(v1=c(1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,6,6),
#'                        v2=c(2,3,6,1,3,4,1,2,4,6,2,3,5,4,6,1,3,5),
#'                       w=c(7,9,14,7,10,15,9,10,11,2,15,11,6,6,9,14,2,9))
#' dijkstra(wiki_graph, 1)
dijkstra <- function(graph, init.node) {
#pseudo code (source = https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
#Checking input
if (nrow(graph) == 0) {
stop("The graph is empty")
}
if (init.node > nrow(graph)){
stop("The initial node is not in the graph")
}
dist <- c()
prev <- c()
my_queue <- c()
#initialize dist and prev
for (i in 1:nrow(graph)){
dist[i] <- Inf
prev[i] <- NA
my_queue[i] <- i
}
#Set the distance to zero for the initial node
dist[init.node] <- 0
#Set the current node to the initial node
current <- init.node
while(length(my_queue) > 0) {
#find the node in the queue with the smallest dist
min_dist <- Inf
for (i in 1:length(my_queue)){
if (dist[my_queue[i]] < min_dist) {
min_dist <- dist[my_queue[i]]
current <- my_queue[i]
}
}
#remove current from Q
my_queue <- my_queue[my_queue != current]
#for each neighbor of current
for (i in 1:nrow(graph)) {
if (graph[i, 1] == current) {
neighbor <- graph[i, 2]
alt <- dist[current] + graph[i, 3]
if (alt < dist[neighbor]) {
dist[neighbor] <- alt
prev[neighbor] <- current
}
}
}
}
#dist is a vector of the shortest distance from the init node to each node
#ie dist[i] is the shortest distance from the initial node to node i
return(list(dist = dist))
}
wiki_graph <-
data.frame(v1 = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6),
v2 = c(2, 3, 6, 1, 3, 4, 1, 2, 4, 6, 2, 3, 5, 4, 6, 1, 3, 5),
w = c(7, 9, 14, 7, 10, 15, 9, 10, 11, 2, 15, 11, 6, 6, 9, 14, 2, 9))
print(dijkstra(wiki_graph, 1))
ls
devtools::use_testthat()
devtools::use_testthat()
usethis::use_testthat()
setwd("~/GitHub/Rprog---github/simgehugo732A94lab3")
usethis::use_testthat()
devtools::uses_testthat()
